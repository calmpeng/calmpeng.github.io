# 14｜集群：哪些环节会存在性能瓶颈和数据可靠性风险？

**将把单机的消息队列架构扩展成为分布式的高可靠、高性能的完整集群**

![image-20251223164536629](进阶篇.assets/image-20251223164536629.png)

从技术上看，消息队列的性能和可靠性由 **生产者**、 **Broker** **集群**、 **消费者** 三方共同保障，而不只是服务端的工作。

全链路耗时，即客户端发出一条消息到消费者消费到这条消息的时间差。

![image-20251223164610130](进阶篇.assets/image-20251223164610130.png)

## 生产者的性能和可靠性

![image-20251225154541887](进阶篇.assets/image-20251225154541887.png)

### 网络层面

**连接协议**、 **传输加密**、 **网路稳定性**、 **网络延时**、 **网络带宽**

生产者客户端会先和 Broker **建立并保持 TCP 长连接**，而不是在每次发送数据时都重新连接，以确保通信的性能。

数据传输过程中，为了避免数据包被篡改、窃取，就需要进行**传输加密**。因为网络质量不稳定，传输过程中可能也存在丢包的情况，此时就需要依赖TCP的重传机制来解决问题。

为了保证延时和吞吐，就需要尽量将客户端和服务端部署在同一个可用区内网中，以避免网络链路带来的影响。

 **一般我们会关注客户端节点网卡、中间网络链路、Broker 节点的网卡三个部分的带宽容量。![image-20251225154944314](进阶篇.assets/image-20251225154944314.png)**



### SDK层面

**发送模式**、 **批量语义**、 **异常处理**、 **生产者数量**

#### 发送模式

在生产端，一般支持发送即忘、同步发送、异步发送三种发送模式，发送模式的设计思想是希望在性能和可靠性之间寻找平衡。

**发送即忘** 是指调用 send() 函数后，不用等待服务端的返回结果，因此可以不断地发送数据。这种模式的性能是最高的，可靠性是最低的，因为数据发送失败后没有任何后续的容错处理。

**同步发送** 是指调用 send() 函数后，业务代码同步等待服务端的返回，优点是能保证发送消息的顺序性，这种模式的性能是最低的。其性能高度依赖Broker和服务端之间的网络延时，以及Broker的处理耗时。

**异步发送** 是指调用 send() 函数后，使用异步线程回调的方式发送数据。即在不阻碍主线程的情况下发送数据，此时业务可以一直不停地发送数据。但是如果 send() 速度大于底层发送给Broker的速度，当SDK底层的线程池用完后，发送数据也会阻塞。

总结一下，**从性能上来看，发送即忘 > 异步发送 > 同步发送**。从可靠性来看，**异步发送 = 同步发送 \> 发送即忘**。**同步发送可以保证顺序，异步发送因为重传机制的存在，会无法保证顺序**

#### 批量发送

批量发送是指生产端是否支持 Batch 语义。批量比非批量的吞吐性能高。

从全链路延时来看，因为批量发送需要在生产者客户端本地等待聚合数据，所以**非批量发送的全链路耗时会比批量发送的全链路延时低**。

#### 异常处理

**一般会在数据发送流程中，做好异常捕获、重试的逻辑，并对发送结果进行记录**。比如发送失败的异常信息，发送时候**记录消息的ID或者能唯一标识消息的信息，从而做到发送数据的可追溯。**

#### 生产者数量

最后，因为单个生产者和单个TCP连接是有性能瓶颈的，在业务中我**建议你建立多个生产端实例同时来写入数据，这样可以提高生产者的性能**。



## Broker 的性能和可靠性

**单机和集群两个维度**。单机维度属于**垂直扩容**，集群维度属于**水平扩容**。



### 单机维度

在单机维度，Broker 的性能和可靠性提升可以拆成应用程序、操作系统、物理硬件三个层面。

![image-20251225161332059](进阶篇.assets/image-20251225161332059.png)

### 集群维度

核心思想就是水平扩容，即通过水平扩容添加节点，让集群拥有更强的处理能力。

消息队列集群中，性能和可靠性是通过**创建更多分区、多个副本，并将分区和副本分配到多个节点**上来实现的

![image-20251225161446017](进阶篇.assets/image-20251225161446017.png)

## 消费者的性能和可靠性

客户端SDK和网络。

 **我们主要关注延时和堆积两个指标**

延时是指Broker保存一条消息后，这条消息被客户端消费到的时间差。

堆积是指Broker堆积很多消息没有被及时消费。

消费者的性能和可靠性主要跟 **消费模型**、 **消费重平衡**、 **消费模式**、 **位点提交** 四个方面有关

![image-20251225161627546](进阶篇.assets/image-20251225161627546.png)

### 消费模型

为了提高消息消费的及时性，最好是选择Push模型，即服务端有消息后主动Push给多个客户端，此时的消费的延时是最低的。从提高吞吐来看，为了避免服务端堆积，主流消息队列都是通过客户端主动批量Pull数据来提高吞吐、避免堆积。 **一般情况下，Pull 模型都是默认的消费模型。**

> **核心结论：Pull模型是权衡后的最优解，在保证系统稳定性的前提下，通过技术优化接近Push的实时性。**
>
> **为什么不用Push？三大致命缺陷：**
>
> 1. **慢消费灾难**：消费者处理能力不足时，Push会持续轰炸导致崩溃
> 2. **控制权缺失**：Broker难以适配不同消费者的异构处理能力
> 3. **资源浪费**：Broker需维护复杂的消费者状态，架构沉重
>
> **为什么用Pull？三大核心优势：**
>
> 1. **自主背压**：消费者按自身能力拉取，天然防过载
> 2. **灵活适配**：不同消费者可定制拉取策略（批量大小、频率）
> 3. **架构简洁**：Broker只负责存储，消费者管理偏移量
>
> **技术折中：长轮询（Long Polling）**
>
> - Pull模式通过“阻塞等待新消息”实现**准实时消费**
> - 消费者拉取时，若无新消息则短暂阻塞（如Kafka默认500ms），有消息立即返回
> - **效果**：延迟接近Push，同时保留Pull的所有优势
>
> **一句话总结**：**Pull用“消费者自主控制”换取了系统稳定性，通过长轮询技术弥补了实时性差距，这是分布式系统可靠性的经典设计。**

### 消费分组

消息队列一般是通过消费分组（或订阅）消费数据，以便能自动分配消费关系和保存消费进度。此时当**消费重平衡时，为了重新分配消费关系，所有的消费都会暂停，从而会影响到消费性能**。如果重平衡次数较多，问题就会更加严重。所以，像Flink等流式计算引擎，都会绕过消费分组，指定分区进行消费，以避免重平衡带来的性能下降。而 **RocketMQ 为了解决重平衡问题，就将重平衡移动到了 Broker 端，尽量降低消费重平衡带来的性能影响**。



### 消费模式

在分配消费关系的时候，如果以**分区粒度将分区分配给一个消费**者，此时当**消费者性能有差别时**，就会出现消费倾斜，**导致分区堆积**，从而影响性能

而如果是以消息粒度投递数据，即一个分区的数据能够投递给不同的消费者，此时就不会出现性能问题，性能是更高的，但是**消息数据的顺序性无法保证**。



### 位点提交

从可靠性来看，消费端是不存在丢数据的情况的。但是客户端如果存在错误提交消费位点（Offset）的情况，比如应该提交 Offset 却没有提交，就会导致重复消费；或者不应该提交Offset 却提交了Offset，就会导致消费者没有消费到应该消费的数据，从而导致下游认为数据丢失。此时从代码上来看，建议是手动提交Offset（或ACK），即消费到数据，并且业务逻辑处理成功后，才执行ACK或者提交Offset。



## 小结

![image-20251223164727503](进阶篇.assets/image-20251223164727503.png)

















