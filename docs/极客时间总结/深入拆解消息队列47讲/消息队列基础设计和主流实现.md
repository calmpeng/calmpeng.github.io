# 消息队列基础设计和主流实现

## 什么是消息队列

从宏观上来讲，认为**具有缓冲作用、具备类发布和订阅能力的存储引擎都可以称做消息队列**。因为消息队列的最基本功能就是生产和消费，在发布订阅之上，扩展如死信队列、顺序消息、延时消息等高阶能力，并实现高吞吐、低延时、高可靠等特性，就成为了我们所熟知的功能齐全的标准消息队列。

![image-20251222010524250](消息队列基础设计和主流实现.assets/image-20251222010524250.png)

## 使用场景

在系统架构中，消息队列的定位就是 **总线和管道**，主要起到解耦上下游系统、数据缓存的作用。

所以，我们在业务中不管是使用哪款消息队列，我们的**核心操作永远是生产和消费数据**。

经典的订单下单流程：

![image-20251222010938972](消息队列基础设计和主流实现.assets/image-20251222010938972.png)

下单流程是一个典型的 **系统解耦**、 **消息分发** 的场景，一份数据需要被多个下游系统处理。

另外一个经典场景就是日志采集流程，一般日志数据都很大，直接发到下游，下游系统可能会扛不住崩溃，所以会把数据先缓存到消息队列中。所以消息队列的**基本特性就是高性能、高吞吐、低延时。**

## 基础概念

### 架构层面的基础概念

![image-20251222011126514](消息队列基础设计和主流实现.assets/image-20251222011126514.png)

1. Broker
2. Topic
3. Parition
4. Produce
5. Consumer
6. ConsumerGroup
7. Message
8. Offest/ConsumerOffest/Cursor
9. ACK/OffsetCommit
10. Leader/Follower
11. Segment
12. StartOffset/EndOffset
13. ACL

### 功能层面的基本概念

消息队列的基本操作就是生产和消费，即读和写。消息队列一般是不支持客户端修改和删除单条数据的常见的基本概念。

1. 顺序消息
2. 延时消息/定时消息
3. 事务消息
4. 消息重试
5. 消息回溯
6. 广播消费
7. 死信队列
8. 优先级队列
9. 消息过滤
10. 消息过期/删除（TTL）
11. 消息轨迹
12. 消息查询
13. 消息压缩
14. 多租户
15. 消息持久化
16. 消息流控



## 基础功能

一个最基础的消息队列应该具备**生产、存储、消费的能力**，也就是能完成“生产者把数据发送到Broker，Broker收到数据后，持久化存储数据，最后消费者从Broker消费数据”的整个流程。

最基础的消息队列应该具备五个模块。

- 通信协议：用来完成客户端（生产者和消费者）和Broker之间的通信，比如生产或消费。
- 网络模块：客户端用来发送数据，服务端用来接收数据。
- 存储模块：服务端用来完成持久化数据存储。
- 生产者：完成生产相关的功能。
- 消费者：完成消费相关的功能。

![image-20251222012207298](消息队列基础设计和主流实现.assets/image-20251222012207298.png)

## 功能如何设计实现

### 通信协议

从功能支持、迭代速度、灵活性上考虑，大多数消息队列的核心通信协议都会优先考虑自定义的私有协议。

私有协议的设计主要考虑网络通信协议选择、应用通信协议设计、编解码实现三个方面。

- 网络通信协议选型，基于可靠、低延时的需求，大部分情况下应该选择TCP。

  ![image-20251222165814075](消息队列基础设计和主流实现.assets/image-20251222165814075.png)

- 应用通信协议设计，分为请求协议和返回协议两方面。协议应该包含协议头和协议体两部分。协议头主要包含一些通用的信息，协议体包含请求维度的信息。

  ![image-20251222165835799](消息队列基础设计和主流实现.assets/image-20251222165835799.png)	

- 编解码，也叫序列化和反序列化。在实现上分为自定义实现和使用现成的编解码框架两个路径。

  ![image-20251222165918273](消息队列基础设计和主流实现.assets/image-20251222165918273.png)

其中最重要的是应用通信协议部分的设计选型，这部分需要设计协议头和协议体。重要的是要思考协议头和协议体里面分别要放什么，放多了浪费带宽影响传输性能，放少了无法满足业务需求，需要频繁修改协议内容。另外，每个字段的类型也有讲究，需要尽量降低每次通信的数据大小。

所以应用通信协议的内容设计是非常考验技术功底或者经验的。有一个技巧是，如果需要实现自定义的协议，可以去参考一下业界主流的协议实现，看看都包含哪些元素，各自踩过什么坑。总结分析后，这样一般能设计出一个相对较好的消息队列。

另外，我们不可能一下子设计出完美的协议，所以核心是保证协议的向前兼容和向后兼容的能力，以便后续的升级和改造。

因为历史发展原因，业界大部分的消息队列的编解码都是自己实现的，只有近年兴起的Pulsar和RocketMQ的新版本选择了Protobuf作为编解码框架。从编解码框架的选择来看，如果是一个全新的项目或架构，使用现成的编解码框架比如Protobuf，是比较好的选择。

### 网络模块

消息队列的网络模块主要解决的是性能、稳定性、成本三个方面的问题。

性能问题，核心是通过 Reactor 模型、IO 多路复用技术解决的。Reactor模式在Java网络编程中用得非常广泛，比如 Netty 就实现了 Reactor 多线程模型。即使不用Netty进行网络编程（比如Kafka 直接基于Java NIO编程）的情况下，网络模块也大多是参考或基于Reactor模式实现的。因为Reactor模式可以结合多路复用、异步调用、多线程等技术解决高并发、大流量场景下的网络模块的性能问题。

![image-20251222170101981](消息队列基础设计和主流实现.assets/image-20251222170101981.png)

在Java技术栈下，网络编程的核心是Java NIO。但为了解决稳定性和开发成本的问题，建议选择业界成熟的网络框架来实现网络模块，而不是基于原生的Java NIO来实现。成熟的框架分为成熟的NIO框架（如Netty）和成熟的RPC框架（如gRPC）。

目前业界主流的消息队列都是基于Java NIO和Netty实现的。Netty是我们网络模块编程的常用选型，大部分情况下，可能还是我们的最终选择。但是Netty好用并不意味着所有的Java网络编程都必须选择Java NIO和Netty。

![image-20251222170152132](消息队列基础设计和主流实现.assets/image-20251222170152132.png)

当你需要构建一个组件的网络模块的时候，你要先知道这个组件的业务特点是什么，需要解决哪些问题，再来考虑使用什么技术。比如在客户端连接数不多、并发不高，流量也很小的场景，只需要一个简单的网络Server就够了，完全没必要选择Java NIO或Netty来实现你的网络模块。随着技术架构的迭代，基于RPC框架的方案也是一个不错的选择。

### 存储模块

消息队列的存储分为元数据存储和消息数据存储两方面。

元数据的存储主要依赖第三方组件实现，比如ZooKeeper、etcd或者自研的简单元数据存储服务等等。在成熟的消息队列架构中，基于简化架构和提升稳定性的考虑，都会考虑在集群内部完成元数据的存储和管理。

![image-20251222170208911](消息队列基础设计和主流实现.assets/image-20251222170208911.png)

![image-20251222170221250](消息队列基础设计和主流实现.assets/image-20251222170221250.png)

消息数据的存储在功能层面包含数据存储结构设计、数据分段存储、数据存储格式、数据清理机制四个方面。

消息数据的存储主要包含Topic和分区两个维度。Topic起逻辑组织作用，实际的数据存储是在分区维度完成的。所以在数据存储目录结构上，我们都以分区为最小粒度去设计，至于选择每个分区单独一个存储文件，还是将每个节点上所有分区的数据都存储在同一个文件，方案各有优劣，你可以根据实际情况去选择。

![image-20251222170241773](消息队列基础设计和主流实现.assets/image-20251222170241773.png)

![image-20251222170247656](消息队列基础设计和主流实现.assets/image-20251222170247656.png)

因为大文件存在性能和资源占用、数据清理成本等问题，一般情况下，我们都需要对数据文件进行分段处理，分段的策略一般都是按照文件大小进行的。

![image-20251222170305251](消息队列基础设计和主流实现.assets/image-20251222170305251.png)

数据存储格式可以分为基础信息和业务信息两个维度，数据格式需要遵循极简原则，以达到性能和成本的最优。

![image-20251222170330552](消息队列基础设计和主流实现.assets/image-20251222170330552.png)

数据的过期策略一般有三种，ACK删除、根据时间和保留大小删除数据、两者结合。目前业界的实现比较多样，从选择上来看，两者结合的方案更合理。

![image-20251222170354002](消息队列基础设计和主流实现.assets/image-20251222170354002.png)

![image-20251222170403053](消息队列基础设计和主流实现.assets/image-20251222170403053.png)

---

写入性能优化的核心是缓存写、批量写、顺序写。

内存的写性能比任何硬盘都高，通过先写内存、后批量刷新数据到硬盘，可以降低硬盘的写入次数，从而提升写入性能。在写缓存的过程中，要注意数据的可靠性，我们可以通过同步刷盘、副本同步、WAL机制等手段提高性能和可靠性。写入的时候，顺序写的性能比随机写的性能高，顺序写的核心是数据存储目录结构的设计。

![image-20251222170428865](消息队列基础设计和主流实现.assets/image-20251222170428865.png)

![image-20251222170459619](消息队列基础设计和主流实现.assets/image-20251222170459619.png)

![image-20251222170509191](消息队列基础设计和主流实现.assets/image-20251222170509191.png)

![image-20251222170516461](消息队列基础设计和主流实现.assets/image-20251222170516461.png)

读操作的性能提升，主要依赖热读、顺序读、批量读、零拷贝四种手段。

![image-20251222170602700](消息队列基础设计和主流实现.assets/image-20251222170602700.png)

热读主要依赖可用内存的大小。批量读指一次IO操作尽可能读取更多的数据，避免多次的数据IO操作。数据预读分为硬盘预读和应用程序预读两类，主要思路都是提前读取数据缓存到内存中，提高热读的命中率。和写入一样，顺序读的核心也是数据存储目录结构的设计。

零拷贝主要用来提升消费的性能，它只是一个概念，不是一门具体的技术。核心思路是 **减少复制和上下文切换的次数，通过DMA技术释放 CPU 的工作量**，从而提升消费性能。底层的实现主要涉及mmap内存映射、sendfile系统调用、DMA直接内存读取三种技术手段。Java代码的实现，mmap和sendfile的操作都在NIO FileChannel类中，对应map、transferTo、transferFrom三个方法的使用。DMA技术在代码中无法控制，依赖于操作系统的实现。

![image-20251222170613202](消息队列基础设计和主流实现.assets/image-20251222170613202.png)

![image-20251222170618959](消息队列基础设计和主流实现.assets/image-20251222170618959.png)

![image-20251222170714661](消息队列基础设计和主流实现.assets/image-20251222170714661.png)

另外，在硬件和操作系统层面，我们还可以通过提升硬件的规格和类型、配置多盘读写、配置RAID和LVM硬盘阵列三种手段来提高性能

### 生产者

![image-20251222170758465](消息队列基础设计和主流实现.assets/image-20251222170758465.png)

消息队列生产者客户端的设计，主要关注下面三个部分。

1. 网络模块的开发和管理。这部分是为了完成和服务端的通信，比如请求和返回的构建、心跳检测、错误处理，重试机制等。
2. 根据服务端提供的各个接口的协议结构，构建请求，完成序列化和反序列化后，通过网络模块发起请求并获得返回。
3. 在前面两步的基础上，添加各个业务层面的功能，比如生产、消费、事务、幂等、SSL等等。

![image-20251222012807612](消息队列基础设计和主流实现.assets/image-20251222012807612.png)

客户端和服务端交互的过程中，一般要经过元数据寻址，以正确找到分区所在的Broker。如果我们想避免客户端寻址，只能在服务端内进行转发，但有性能和资源的损耗。所以在主打吞吐的消息队列组件中，转发的方案用得很少。

![image-20251222170828234](消息队列基础设计和主流实现.assets/image-20251222170828234.png)

![image-20251222170836997](消息队列基础设计和主流实现.assets/image-20251222170836997.png)

从生产者的角度来看，需要重点关注分区分配策略、批量语义、发送方式三个方面。请求内容构建和序列化属于协议设计的内容，主要取决于协议的具体设计和序列化/反序列化框架的选择。

![image-20251222170859227](消息队列基础设计和主流实现.assets/image-20251222170859227.png)

![image-20251222170916256](消息队列基础设计和主流实现.assets/image-20251222170916256.png)

### 消费者

在消费端，为了提高消费速度和消息投递的及时性，需要选择合适的消费模型，目前主流有Pull、Push、Pop三种模型。

![image-20251222170956198](消息队列基础设计和主流实现.assets/image-20251222170956198.png)

![image-20251222171021448](消息队列基础设计和主流实现.assets/image-20251222171021448.png)

![image-20251222171105435](消息队列基础设计和主流实现.assets/image-20251222171105435.png)

这三种模型的应用场景都不一样。目前业界主流消息队列使用的都是Pull模型。但为了满足业务需求，很多消息队列也会支持Push模型和Pop模型。其中，Push模型的及时性更高，实现较为复杂，限制较多。Pop模型本质上是Pull模型的一种，只是在实现和功能层面上，与Push的实现思路和适用场景不一样。所以在模型的选择上来看，因为场景复杂，三种模型都是需要的。

常用的消费模式一般有独占消费、共享消费、广播消费、灾备消费四种 **。** 为了避免堆积，保证消息消费顺序，一般需要选择分区独占的消费模式。从单分区的维度，共享消费的性能是最高的。广播消费主要是通过创建多个消费分组、指定分区消费来实现的。灾备消费的场景用得相对较少。

---

从设计上看，消费端要解决的问题依次分为三步：

1. 满足基本的消费需求，能消费到数据，确认数据。
2. 满足稳定性和性能的需求，能快速稳定地消费到数据。
3. 支持功能方面的需求，比如回溯消费、消费删除、广播消费等等。

为了能满足基本的消费需求，服务端会提供消费和确认接口，同时在客户端封装消费和确认操作中，底层通过网络层和服务端建立、维护TCP连接，然后通过协议完成基本的消费操作。

如果要回溯消费，则需要单独记录消费进度。这样就能抽象出消费分组的概念，用来管理消费者、分区、消费进度的关系。通过消费分组来记录消费进度，从而实现数据的多次分发。另外，消费分组机制也可以用在广播消费的场景。

![image-20251222171230987](消息队列基础设计和主流实现.assets/image-20251222171230987.png)

在消费确认的过程中，一般需要客户端回调服务端提供的确认接口。确认接口分为确认删除和确认记录消费进度两种模式。主流方式是在确认的时候记录消费进度。

![image-20251222171327816](消息队列基础设计和主流实现.assets/image-20251222171327816.png)

![image-20251222171337914](消息队列基础设计和主流实现.assets/image-20251222171337914.png)

异常处理主要是为了保证数据能被正常消费，重点关注不丢数据、不重复消费、不阻塞住消费三个问题，我们需要针对不同的问题做不一样的处理。

## 主流消息队列实现方案

![image-20251222171403511](消息队列基础设计和主流实现.assets/image-20251222171403511.png)

![image-20251222171536323](消息队列基础设计和主流实现.assets/image-20251222171536323.png)



![image-20251222171414980](消息队列基础设计和主流实现.assets/image-20251222171513596.png)

![image-20251222171553994](消息队列基础设计和主流实现.assets/image-20251222171553994.png)



![image-20251222013013351](消息队列基础设计和主流实现.assets/image-20251222013013351.png)



## 参考

[深入拆解消息队列 47 讲](https://time.geekbang.org/column/intro/100552001)