学习地址：[深度优先搜索理论基础](https://programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E6%B7%B1%E6%90%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#dfs-%E4%B8%8E-bfs-%E5%8C%BA%E5%88%AB) 

## dfs 与 bfs 区别

- dfs是**可一个方向去搜**，不到黄河不回头，直到遇到绝境了，搜不下去了，再换方向（**换方向的过程就涉及到了回溯**）。

- bfs是先把**本节点所连接的所有节点遍历一遍**，走到下一个节点的时候，再把连接节点的所有节点遍历一遍，搜索方向更像是广度，四面八方的搜索过程。



总结：

- 搜索方向，是认准一个方向搜，直到碰壁之后再换方向
- 换方向是撤销原路径，改为节点链接的下一个路径，回溯的过程。



## 代码框架

正是因为dfs搜索可一个方向，并需要**回溯**，所以用**递归的方式来实现是最方便的**。

```java
void dfs(参数) {
    处理节点
    dfs(图，选择的节点); // 递归
    回溯，撤销处理结果
}
```

回溯操作就在递归函数的下面，递归和回溯是相辅相成的



```java
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }
    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}

```



代码框架：

```java
vector<vector<int>> result; // 保存符合条件的所有路径
vector<int> path; // 起点到终点的路径
void dfs (图，目前搜索的节点)  

void dfs(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本节点所连接的其他节点) {
        处理节点;
        dfs(图，选择的节点); // 递归
        回溯，撤销处理结果
    }
}
```





